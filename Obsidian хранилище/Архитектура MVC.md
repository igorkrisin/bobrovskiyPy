#swift #mvc #architect 

## **MVC без Apple**

Мы же пока разберём _MVC_ в обычном виде. **_M_****_V_****_C_** — это паттерн, который помогает разделить логику приложения на три части, и набор букв, где каждая отражает одну из частей логики:

- **_Model_** — Модель → получает данные от контроллера, обрабатывает нужные операции и отправляет их во _View._
- **_View_** — Вью как представление → получает данные от модели и показывает их пользователю.
- **_Controller_** — Контроллер → обрабатывает пользовательские действия вместе с полученными данными и отправляет их на модель.

Теперь подробнее о том, о чём тут в принципе речь, но на примерах приложений.

**Модель** — это то, что скрыто от пользовательского глаза, то, что мы никак не можем увидеть, когда пользуемся приложением. Например, мы видим любимые треки в приложении с музыкой, но мы же не то что не знаем, а в принципе не думаем, как они туда попадают и откуда подтягиваются. Понятное дело, что они подтягиваются с сервера, иначе айфонам было бы мало даже 512 ГБ в максимальной комплектации. Поэтому, есть определённая модель внутри приложения, согласно которой происходит работа по ту сторону занавеса. На этой модели может быть всё, что угодно: методы, сущности и так далее.

**Вью** (или представление) — то, что мы видим на экране телефона, когда заходим в приложение в первый раз и когда в принципе пользуемся приложением. Это та видимая часть, на которой пользователь видит данные. В эту видимую часть приложения данные отправились из модели, и они выглядят так, чтобы пользователь мог их посмотреть. Другими словами, мы видим интерфейс нашего плеера, а он отображает треки с сервера, которые прислала модель — собственно, перед нами вью, то есть представление модели.

**Контроллер** — компонент, который обрабатывает действия пользователя на экране приложения и, получив данные, он отправляет их в модель. Опять-таки, по сравнению с _view_, мы его не видим. Он работает, когда мы хотим найти какую-то песню или альбом — мы вводим название в _search bar_, или когда хотим убавить/прибавить громкость — задаём какое-то число при помощи _slider_ в диапазоне от 0 до 100. Контроллер обрабатывает пользовательские действия, отправляет их в модель — вернее, он отправляет **данные** на основе пользовательских действий. Модель в свою очередь получает новые параметры для работы.

## Скринкаст на тему: «MVC на примере сайта Skillfactory‎»

С помощью _MVC_ мы можем написать независимые логические блоки кода, которые можно изменять отдельно, при этом не меняя другие. К примеру, мы хотим сделать абсолютно другой способ работы с данными — добавить в него сортировку пузырьком, например, но при этом не менять способ их отображения. По идее, мы пишем разные компоненты, которые никак не зависят друг от друга, но их можно друг к другу подключать.

Пример из реальной жизни — Макдональдс. Обозначим роли:

- покупатели → пользователи
- касса и кассир → вью и контроллер
- внутренняя кухня → модель

1. Покупатель (пользователь) подходит к кассе (вью), видит список меню и набирает заказов по своему усмотрению.
2. Кассир (контроллер) согласовывает заказ с покупателем и после оплаты направляет информацию на кухню (модель).
3. Кухня (модель) готовит заказ. При этом кухня не знает, оплачен ли заказ, кем является покупатель, зачем ему это всё и тому подобное.
4. Как только кухня (модель) приготовит заказ, она отправит результат на кассу (вью).
5. Уже на кассе (вью) покупатель (пользователь) **увидит** и получит свой заказ.

В 1978 году, на момент появления, модель _MVC_ в классическом и максимально общем виде выглядела вот так:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/930676a5894da1486ef6f0ce00976a91/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p2.png)

Источник: [ru.wikipedia.org](https://ru.wikipedia.org/wiki/Model-View-Controller)

Затем автор _MVC_ в 2009 пересмотрел её в прикладном аспекте и получилось вот что:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/070f8a0e245bdc2f3811ca0b0ad0d36a/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p3.jpg)

Источник: [artima.com](https://www.artima.com/articles/dci_vision.html)

Кстати, ошибочно утверждать, что элементы _MVC_ в каждом конкретном случае взаимодействует согласно одному какому-то единственному правилу. На самом деле, каждый раз, когда вы что-то создаёте на _MVC_-архитектуре, то вы не устанавливаете какое-то универсальное решение архитектуры: вы так или иначе расширяете рамки взаимодействия между _MVC_-компонентами.

Плюс, забегая вперёд, не исключено, что вы даже соединяете две архитектуры в одной; можно и более, только всё упирается в удобство решения.

В настоящее время _MVC_ претерпела изменения. Если говорить про _MVC_ от _Apple_, то она выглядит немного даже страшно. Готовы порадовать — так только на схеме архитектуры. В реальных проектах всё будет немного иначе, потому что архитектурная схема хорошо выглядит на картинке, то есть в идеальном представлении. Ведь в реальности всё может быть либо немного иначе, либо абсолютно иначе.

В развёрнутом виде современный _MVC_-паттерн выглядит примерно так:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/541ca8b4bd79053346b7be68a849f4fc/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p4.png)

Источник: [Habr, блог Badoo](https://habr.com/ru/company/badoo/blog/281162/)

Не будем забывать, что в разных сферах программирования, например, в веб-программировании, модель _MVC_ обросла своими нюансами при реализации и утратила свой первозданный вид. Вместе с нюансами _MVC_ обросла и проблемами.

1. Самая очевидная проблема — внедрение модели, когда вы максимальный новичок. Это в принципе стоит считать нулевой проблемой, потому что будучи новичком вы вообще можете укладывать всю логику приложения в единственном файле под названием _ViewController_. Потом может наступить момент «пора что-то менять», и ваш самый первый код получает такие изменения, как внедрение логики в отдельный файл — по сути это и есть создание модели. _ViewController.swift_ обращается к модели за выполнением методов — и у вас теперь вызываются методы, которые лежат максимально далеко от _ViewController.swift._  
      
    Решение: **опыт**. Тут имеет смысл брать свой старый код и максимально переписывать под _MVC_-паттерн всё, что можно переписать. Если есть что-то такое, что не вписывается в _MVC_ (хотя вряд ли), то лучше пока это не трогать. Возможно, это уже не про _MVC_.
2. Есть негласное правило в компаниях: если ваш код — не что иное, как хаос, внедряйте _MVC_. На вопрос «Почему?» ответа нет. Это выглядит так, словно так заведено, словно это такая традиция. В основном в коммерческой разработке утверждают, что _MVC_ даёт общую концепцию системы (приложения) и упрощает процесс отладки. Возможно, код работает, решает проблему, но он не _MVC_, поэтому вас попросят переписать. Решения у этой проблемы нет — действительно приходится внедрять MVC-паттерн.
3. _MVC_ просит большое количество ресурсов. Все три фундаментальных блока независимы и взаимодействуют между собой по принципу передачи данных: контроллер должен загружать/создавать все комбинации переменных и передавать их на модель. Модель должна загрузить все данные для подготовки отрисовки и отдать их на _view_.  
      
    Решение: расширение архитектуры самого приложения, **создание более гибких решений**.
4. Разделить программу на модули — та ещё задачка. Ведь в концепции _MVC_ чётко и строго прописано наличие трёх блоков. Значит, каждый функциональный модуль должен состоять из трёх блоков, а это усложняет архитектуру функциональных модулей программы. Решения нет, зачастую всё сводится к увеличению времени работы над модулями.
5. Логично следует из четвёртого сложный процесс расширения функционала. Здесь всё упирается в то, что сделать функциональный модуль и подключить его в конкретном месте программы становится недостаточно. _MVC_ просит просит больше ресурсов — каждый функциональный модуль по умолчанию состоит из трёх частей, а каждая из этих частей подключена в соответствующем блоке.

Кстати, _Apple_ не просто «завезли» собственную _MVC_. Как мы знаем, после любых действий идут последствия. Соответственно, у _MVC_ от _Apple_ тоже есть скоп проблем из-за «философии», которую они вкладывали в свою версию этого архитектурного паттерна. О проблемах _MVC_ от _Apple_ и их решении поговорим далее.

### Задание 24.3.1

1 point possible (graded)

Чем полезна _MVC_ для приложения?

Помогает сделать приложение быстрее.

Помогает сделать элементы автономными.

Помогает разгрузить контроллер.

нет ответа

Hint

Отправить

Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.

## **MVC от Apple**

Мы плавно подобрались к версии _MVC_, которую переработала _Apple_. Из попытки создать свой _MVC_-паттерн у _Apple_, конечно, получился результат, но не самый ожидаемый.

### Ожидание:

Контроллер посредничает между моделью и вью. Значит, модель и вью не знают о существовании друг друга (помните пример про Макдональдс?). Отсюда контроллеру тяжеловато делать какое-либо переиспользование. По логике _Apple_, программистам так нормально, ибо у нас должно быть место для бизнес-логики, если она не вписалась в модель.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/5e3358917e9836b13b9f34804794d4a2/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p5.png)

Источник: [Habr, блог Badoo](https://habr.com/ru/company/badoo/blog/281162/)

Чтоб вы понимали, задумывалось сделать три блока по классике, только распределить по ним пользовательские действия, обновления и внутрисистемные уведомления (пожалуйста, не путайте с _push_-уведомлениями).

### Реальность:

_MVC_ как _Model View Controller_ перерастает в _Massive View Controller,_ при этом _Cocoa_ нормально к этому относится → раздуваем из мухи слона, но всё ок. Контроллер настолько привязан к жизненному циклу вью, что его трудно выделить в качестве отдельной сущности. Если даже мы и разгрузим контроллер через модель, то вью всё равно отвечает за отправку действий к контроллеру. В результате, _ViewController_ принимает несколько новых ролей:

- источник данных
- делегат
- место запуска и отмены серверных запросов
- всего, чего фантазия придумает

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/f5e8cce43d83d35f4fc8427da5544dec/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p6.png)

Источник: [Habr, блог Badoo](https://habr.com/ru/company/badoo/blog/281162/)

Что в итоге: вью с контроллером объединены, их разлучить невозможно, такой вот идеальный финал для повести о Ромео и Джульетте. Контроллер в этой «семье» несёт всю непосильную ношу — максимально зависит от вью, обрабатывает пользовательские действия и отдаёт их на модель. Модель же после всех закулисных вычислений отправляет в эту «семью» обработанные данные, чтобы вью показал их пользователю.

Это в принципе логично: _Apple_ позаботилась о разработчиках — есть в _UIKit_ комплексный модуль _ViewController_ и соответствующий класс, а значит, вместо двух компонентов мы создаём один, но на выходе получаем два.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/60998da07d05ac82cc6dd9f2e91a724f/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p7.png)

Источник: [memepedia.ru](https://memepedia.ru/stonks/)

*Мем _Stonks_ носит исключительно развлекательный характер и привязан к параллели между выгодой от получения чего-либо бесплатно и получением двух компонентов при создании _ViewController._

**Нюанс:** это выглядит так при комбо-взаимодействии кода и сториборда. Если мы работаем без сториборда, то, разумеется, мы будем создавать контроллер отдельно, вью отдельно, а про модель и говорить не стоит — её тоже надо будет написать.

### Задание 24.3.2

1 point possible (graded)

Этот элемент и представление настолько неразлучны, что его даже трудно описать в качестве чего-то отдельного.

Модель

Вью

Контроллер

нет ответа

Hint

Отправить

Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.

## **Практика**

Мы понимаем, что прямо сейчас сходу вы не броситесь делать приложение для задач типа _ToDoList_. Поэтому в этом юните мы шэрим исходный код приложения, в котором настроено отображение таблицы, уже установлены кнопки редактирования и удаления, выставлен параметр для выполненных задач и прочие визуальные штуки, о которых нам пока думать не нужно. 

Нам нужно понять принцип, как в этом приложении реализуется _MVC_.

[Скачать _ToDoList_, исходный код](https://lms-cdn.skillfactory.ru/assets/courseware/v1/49b39056579ac0915d556ec3604d8dd8/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ToDoListFromTaskMVC.zip)

В качестве примера работы с _MVC_ мы рассмотрим два файла из проекта _ToDoList_ — _Model.swift_ и _TableViewController.swift_. Очевидно, что _Model_ отвечает за модель, _View_ у нас — это _UIViewController_ на сториборде, а _Controller_ соответственно  _TableViewController.swift._

Из чего состоит наш _ToDoList_? Если брать _MVC_, то компоненты будут идти по порядку букв в этой аббревиатуре.

**_Model_** — на ней описаны сущности и методы работы с данными, забирает данные на обработку:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/235a60cb77cf1ef383ec12a99389d712/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p8.png)

**_View_** — то, что нам представлено, по сути весь визуал приложения: ячейки + кнопки, то есть всё то, что визуализирует работу модели:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/bb3391c41df05ee5c1f0de0525b912e4/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p9.png)

**_Controller_** — компонент, который обрабатывает пользовательские действия и отправляет данные в модель:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/05644c538b4d0a183be5b740b60735b9/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p10.png)

Итак, в _Model.swift_ мы описываем сам объект, который будет передавать модель:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/b0755f2946338c9c1c4a90fffaa6e040/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p11.png)

Затем, выделяем класс для модели: 

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/731facd5df4c1e8a1434000578f58a3f/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p12.png)

В этом классе мы добавляем _properties_ и методы, с которыми будет работать как сама модель, так и контроллер. Предположим, мы хотим, чтобы у нас по дефолту подгружались какие-то данные в таблицу. Сделаем массив из трёх объектов, который мы будем передавать на _View_:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/49e15197717b4e0b2e9acef318bd41b3/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p13.png)

Заметьте, что у объектов есть два параметра: один отвечает за текст, другой — за галочку-чекмарк.

Теперь идём в _TableViewController_ и смотрим на строчки кода с 43 по 58. Это два важнейших метода протокола _UITableViewDataSource_, без которых мы симулятор не отрисует нам таблицу. Мы молчим уже про дальнейшее функционирование.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/8991767a8217c2a34a89f4a4bb826180/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p14.png)

Метод `numberOfRowsInSection` возвращает значение, которое он считает по модели: мы передаём массив toDoItems с модели _Model_, а не создаём его на контроллере _TableViewControler.swift._ Мы можем выполнить count на контроллере, это окей, но если у нас _MVC,_ то данные должна передавать модель.

Метод `cellForRowAt indexPath` возвращает ячейку. При этом мы снова передаём из модели значения в customTextLabel. Плюс за появление галочки на ячейке у нас отвечает метод, который обращается к toDoItems в модели, к его параметру completed.

Так как в проекте у нас кастомная ячейка, то мы используем тайпкастинг, через который обозначаем, что это не просто cell, а кастомная ячейка:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/db866e23aa19561da173024d3fcba20e/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p15.png)

Вот класс, в котором описана наша ячейка.

Далее, после 58 строчки идут методы, без которых мы можем обойтись в усеченном варианте приложения _ToDoList_. Поэтому если мы запустим приложение в симуляторе только имея numberOfRowsInSection и cellForRowAt indexPath, то результат получим вот такой:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/eee671fb5fc073a9727200e8fc0d84b4/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p16.png)

Так или иначе, результат показывает, что _MVC «_произошёл».

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/ff58f82f259bc83e13c0a7a2e3dd969c/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p17.png)

Источник: [meme-arsenal.com](https://www.meme-arsenal.com/create/chose?tag=%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%BE%D1%88%D0%B5%D0%BB%20%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B8%D0%BD%D0%B3%20%D0%BA%D0%BE%D1%82)

Да, _it works_! Вот примерно так и работает _MVC_ на минималках. Давайте отправимся ещё немного вперёд в плане понимания _MVC_ и того, что с ним можно делать. Рассматривать мы будем всё тот же _ToDoList_, потому что у нас есть методы, о которых стоит поговорить. Снова вернёмся на _Model.swift:_

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/fcabdac918a3dc8b03bf8d177a6d9e8f/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p18.png)

Что мы имеем? Ещё три проперти и шесть методов, которые у нас отвечают за создание, удаление, перемещение данных и изменение состояния задачи с невыполненной на выполненную. Плюс ещё один метод у нас отвечает за сортировку.

Касательно переменных-проперти, они помогают нам работать с кнопками типа _“Edit”_ и _“Sort”_ на контроллере. И по идее, когда мы обрабатываем нажатие на эти кнопки, то проперти подтягивается с модели, а это значит, что _MVC_ реализуется даже в таких мелочах. Если уж вообще придерживаться паттерна _MVC_ на максималках, то нам стоит сказать, что так правильно делать: методы, проперти, данные — в модели, вызов и обращение к этим элементам — на контроллере.

Где ещё в контроллере мы видим явную реализацию _MVC_? Окей. Для начала перейдём на _TableViewController.swift_ и найдём диапазон строчек с 64 по 72. В этих строчках у нас описан метод для выбора конкретной ячейки — `didSelectRowAt indexPath`. Если мы нажмём на какую-то ячейку, то у нас появится галочка, что будет говорить о выполненной задаче. На модели у нас есть метод `changeState`. Как раз-таки мы его будем вызывать в `if-closure` (67-71 строчки) для появления и отключения галочки в ячейке с задачей:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/7d0abebce610c249421112aea8ea8882/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p19.png)

Иными словами, `didSelectRowAt indexPath` — метод контроллера, но чтобы отобразить галочку или наоборот убрать её, ему помогает модель, вернее _её соответствующий метод._

Далее идёт неиспользуемый метод, но он использовался ранее. Ранее в приложении был метод удаления по свайпу и через активацию режима удаления. В общем, две функции, выполняющие одно и то же действие. Что мы опять видим: если мы удаляем задачу, то снова обращаемся к модели и в ней удаляем соответствующий элемент массива:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/9021fa4eec1912dbc31a06cd5bd4c14e/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p20.png)

Кстати, вы можете удалить этот метод из кода, который мы вам пошэрили. Всё равно там за удаление отвечает кнопка на кастомной ячейке.

Что ещё? С активацией стандартного режима редактирования у нас был _drag-n-drop_ на минималках: мы могли сделать долгое нажатие по ячейке и переместить её вверх или вниз. При этом мы обращались к методу в модели, который реорганизовал наш массив, а потом просто обновляли таблицу, ибо массив был изменён и эти результаты нужно так же показывать на _View_, то есть на таблице:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/b059f04f2d36ca86e575e4eb3b62a3ee/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p21.png)

Этот метод вы тоже можете удалить, заодно научитесь, как чистить код от мусора и просто не используемых методов/проперти.

А вот тут вообще сок — 89-127. Вкратце здесь есть два метода, в котором второй помогает первому.  
То есть, `leadingSwipeActionsConfigurationRowAt indexPath` — метод, который создаёт свайп с левого бока таблицы. Но сам он не создаст внутри себя необходимую логику для редактирования задачи, поэтому мы ещё создали `editCellContent`, где отрисовывается окно для изменения данных. И вот именно `editCellContent` работает с моделью — 120 строчка — вызывает метод `updateItem` с модели:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/1ed58161870c1dba0dd97e1ee1b6a028/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p22.png)

Кстати, `leadingSwipeActionsConfigurationRowAt indexPath` тоже можно удалить — после создания кастомной ячейки он не несёт особой пользы.

Продолжаем наш забег по строчкам. Со 142 по 180 строчки у нас есть метод, который обрабатывает нажатие кнопки из контроллера (кнопка с плюсиком):

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/76b8ba5665d72f057e441ee50d9a5c4c/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p23.png)

Что тут у нас происходит? Добавляем задачу с нуля. Поэтому после написания какого-то текста в окне добавления и при нажатии на клавишу _Submit_, мы снова обращаемся к модели, потому что нам нужно куда-то записать наш новый объект, который мы создали. А хранятся они у нас в массиве. А массив на модели. Отсюда 163 и 166 строчки — вызов `addItem` с _Model.swift:_

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/194a490b6d0ce283bb04bf734417d579/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p24.png)

Метод для обработки нажатий на кнопку на контроллере в виде карандашика включает тот самый стандартный режим редактирования, о котором мы уже говорили. Когда режим не включен, у нас обычный карандаш. Когда режим включен, то карандаш перечёркнут — способ показать, как отключить режим:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/76b8ba5665d72f057e441ee50d9a5c4c/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p25.png)                  ![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/3f768e7ea3157636786816d14739189c/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p26.png)

Так как проперти `editButtonClicked` у нас на модели и изначально равно `false`, то мы снова будем работать с моделью. Можно было вообще `editOn` и `editOff` тоже перенести на модель, тогда наш код сократился бы на две строчки. Но глобально это неважно.

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/53695c8dea62f72c02defba3eb637e32/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p27.png)

И, наконец, **сортировка** — кнопочка со стрелкой вверх:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/76b8ba5665d72f057e441ee50d9a5c4c/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p28.png)                  ![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/616bc5aaebe6778a1099d9558b2c47fe/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p29.png)

Аналогичная история — обрабатываем нажатие, чтобы менять способ сортировки. Но ведь сортироваться у нас должны не ячейки, а их закулисье — то есть массив, а отсортированный массив уже отдаём на _view_ и видим результат. Поэтому всё так же обращаемся к модели:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/27f58371c78146419921debafd8a5f35/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p30.png)

Так как проперти `sortedAscending` у нас на модели и изначально равно `true`, то мы снова будем работать с моделью. Можно было вообще перенести `arrowUp` и `arrowDown` тоже на модель, тогда наш код сократился бы на две строчки. Но опять-таки это тоже сейчас не так важно.

И ещё стоит сказать о кнопках на ячейках. Суть в том, что `deleteCell` как метод обработки кнопки редактирования задачи тоже обращается к модели, чтобы удалить элемент массива при удалении задачи. Нам ведь недостаточно красивого исчезновения ячейки, нам нужно удалить элемент из самого хранилища:

![img](https://lms-cdn.skillfactory.ru/assets/courseware/v1/771ac280dbdfaf1f9bb0ec4decffbf40/asset-v1:SkillFactory+iOS-2.0+2021+type@asset+block/ios_27_u3_p31.png)

В скринкасте мы добавим больше примеров к этим методам, потому что на видео можно понять больше, что и как работает.

## Скринкаст на тему: «‎Обозр приложения на MVC»

Такие программы, как _ToDoList,_ довольно популярны в системах развития разработчиков. Например, вы пришли работать в какую-нибудь аутсорсинговую компанию, или же компания-продукт дала вам тестовое задание. Вероятность того, что вас попросят поработать с _TableView_, — очень высока. Ведь по большому счёту большинство приложений реализованы на _CollectionView_ и _TableView_. Вот вы пилите свой _ToDoList_, а ментор или собеседующий техлид говорит: «Всё здорово, только внедрите _MVC_ в своё приложение.» Окей.

Как мы можем видеть, _MVC_ от _Apple_ наводит порядок в структуре проекта и во взаимодействиях между компонентами. Бывает так, что новички пишут код и при этом всю логику работы с данными сразу пишут на контроллере. Получается приложение из одного контроллера, что в сообществах _iOS_-разработчиков (и любых других профессиональных разработчиков) является дурным тоном. Как мы уже говорили, с вашим кодом будут работать другие люди + когда всё структурно, то удобнее читать код и вносить в него изменения даже самому. Зачем пилить сук, на котором сидишь.